import type { Engine, Scene, Loadable } from 'excalibur'
import path from 'path'
import type { MerlynConfig } from '../config.js'
import { writeIfChanged, getRouteName } from '../utils/index.js'
import { walk } from '../utils/fs.js'
import { format } from 'prettier'
import type { Transition } from 'excalibur-router'
import { existsSync } from 'fs'

export interface Manifest {
  title: string
  game: Engine
  transition?: Transition
  devtool?: { enabled?: boolean }
  scenes: {
    boot: string
    files: Record<string, SceneData>
  }
  loaders: {
    files: Record<string, typeof Scene>
    resources: Loadable<any>[]
  }
}

export type SceneData =
  | typeof Scene
  | (() => Promise<{ default: typeof Scene }>)

export function writeManifest(
  cwd: string,
  outDir: string,
  config: MerlynConfig
) {
  writeIfChanged(
    path.join(cwd, `${outDir}/manifest.js`),
    format(manifest(cwd, outDir, config), { parser: 'babel' })
  )
}

function manifest(cwd: string, outDir: string, config: MerlynConfig) {
  const sceneImports = new Set()
  const loaderImports = new Set()

  let loaders: Record<string, string> = {}
  const scenes: Record<string, { isPreloaded?: boolean; path?: string }> = walk(
    config.scenes.path
  ).reduce((acc, name) => {
    const key = getRouteName(name, config.scenes.path)
    const isPreloaded = isScenePreloaded(key, config)
    const scenePath = path.relative(outDir, path.join(config.scenes.path, name))

    if (isPreloaded) {
      sceneImports.add(
        `import ${toVarName(key, '_scene_')} from '${scenePath}'`
      )
    }

    acc[key] = {
      isPreloaded,
      path: scenePath,
    }
    return acc
  }, {})

  if (existsSync(config.loaders.path)) {
    loaders = walk(config.loaders.path).reduce((acc, name) => {
      const key = getRouteName(name, config.loaders.path)
      const loaderPath = path.relative(
        outDir,
        path.join(config.loaders.path, name)
      )
      const varName = toVarName(key, '_loader_')
      loaderImports.add(`import ${varName} from '${loaderPath}'`)
      acc[key] = varName
      return acc
    }, {})
  }

  if (!loaders?.default) {
    loaders ??= {}
    loaders.default = 'DefaultLoader'
    loaderImports.add(`import { DefaultLoader }from 'merlyn/loaders'`)
  }
  if (!loaders?.boot) {
    loaders ??= {}
    loaders.boot = 'BootLoader'
    loaderImports.add(`import { BootLoader }from 'merlyn/loaders'`)
  }

  return /* js */ `
    /* this file is generated by merlyn */

    // import loading scenes first, get any resources used by them
    import { queuedResources } from '$game'    
    ${Array.from(loaderImports).join('\n')}
    const loaderResources = [...queuedResources]
    // end of loading scenes
    
    // import preloaded scenes
    ${Array.from(sceneImports).join('\n')}
    // end of preloaded scenes

		import * as _game from ${JSON.stringify(
      path.relative(outDir, path.join(cwd, config.game))
    )};

    export const devtool = ${JSON.stringify(config.devtool)};
    export const game = _game.default;
    export const transition = _game.transition
    export const title = ${JSON.stringify(config.title)}

		export const scenes = {
      boot: ${JSON.stringify(config.scenes.boot)},     
      files: {
        ${Object.entries(scenes)
          .map(([key, value]) => {
            return `${JSON.stringify(key)}: ${
              value.isPreloaded
                ? toVarName(key, '_scene_')
                : `() => import("${value.path}")`
            }
          `
          })
          .join(',')}
      }
    }

    export const loaders = {
      resources: loaderResources,
      files: {
        ${Object.entries(loaders)
          .map(([key, value]) => `${JSON.stringify(key)}: ${value}`)
          .join(',\n')}
      }
    }
  `
}

function isScenePreloaded(name: string, config: MerlynConfig) {
  if (typeof config.scenes.preload === 'boolean' || !config.scenes.preload) {
    return !!config.scenes.preload
  }

  return config.scenes.preload.includes(name)
}

function toVarName(name: string, prefix: string) {
  return `${prefix}${name.replace(/[^a-zA-Z0-9]/g, '_')}`
}
